{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.wrapInDispatch = wrapInDispatch, exports.mapWithFirebaseAndDispatch = mapWithFirebaseAndDispatch;\n\nvar _mapValues2 = _interopRequireDefault(require(\"lodash/mapValues\")),\n    _isObject2 = _interopRequireDefault(require(\"lodash/isObject\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr)) {\n    var _arr = [],\n        _n = !0,\n        _d = !1,\n        _e = void 0;\n\n    try {\n      for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        _n || null == _i[\"return\"] || _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction wrapInDispatch(dispatch, _ref) {\n  var ref = _ref.ref,\n      meta = _ref.meta,\n      method = _ref.method,\n      _ref$args = _ref.args,\n      args = void 0 === _ref$args ? [] : _ref$args,\n      types = _ref.types,\n      _types = _slicedToArray(types, 3),\n      requestingType = _types[0],\n      successType = _types[1],\n      errorType = _types[2];\n\n  return dispatch({\n    type: (0, _isObject2.default)(requestingType) ? requestingType.type : requestingType,\n    meta: meta,\n    payload: (0, _isObject2.default)(requestingType) ? requestingType.payload : {\n      args: args\n    }\n  }), method.apply(void 0, _toConsumableArray(args)).then(function (payload) {\n    return dispatch({\n      type: (0, _isObject2.default)(successType) ? successType.type : successType,\n      meta: meta,\n      payload: (0, _isObject2.default)(successType) ? successType.payload : payload\n    }), payload;\n  }).catch(function (err) {\n    return dispatch({\n      type: errorType,\n      meta: meta,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\n\nfunction createWithFirebaseAndDispatch(firebase, dispatch, dispatchFirst) {\n  return function (func) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\n      return func.apply(firebase, dispatchFirst ? [dispatch, firebase].concat(args) : [firebase, dispatch].concat(args));\n    };\n  };\n}\n\nfunction mapWithFirebaseAndDispatch(firebase, dispatch, actions, reverseActions) {\n  var withFirebaseAndDispatch = createWithFirebaseAndDispatch(firebase, dispatch),\n      withDispatchAndFirebase = createWithFirebaseAndDispatch(firebase, dispatch, !0);\n  return _objectSpread({}, (0, _mapValues2.default)(actions, withFirebaseAndDispatch), {}, (0, _mapValues2.default)(reverseActions, withDispatchAndFirebase));\n}","map":null,"metadata":{},"sourceType":"script"}