{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = createFirebaseInstance, exports.getFirebase = getFirebase;\n\nvar _merge2 = _interopRequireDefault(require(\"lodash/fp/merge\")),\n    _isObject2 = _interopRequireDefault(require(\"lodash/isObject\")),\n    _utils = require(\"./utils\"),\n    _actions = require(\"./utils/actions\"),\n    authActions = _interopRequireWildcard(require(\"./actions/auth\")),\n    queryActions = _interopRequireWildcard(require(\"./actions/query\")),\n    storageActions = _interopRequireWildcard(require(\"./actions/storage\"));\n\nfunction _getRequireWildcardCache() {\n  if (\"function\" != typeof WeakMap) return null;\n  var cache = new WeakMap();\n  return _getRequireWildcardCache = function () {\n    return cache;\n  }, cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) return obj;\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) return cache.get(obj);\n  var newObj = {};\n\n  if (null != obj) {\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];\n    }\n  }\n\n  return newObj.default = obj, cache && cache.set(obj, newObj), newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(source, !0).forEach(function (key) {\n    _defineProperty(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nvar firebaseInstance;\n\nfunction createFirebaseInstance(firebase, configs, dispatch) {\n  configs.enableLogging && firebase.database && \"function\" == typeof firebase.database.enableLogging && firebase.database.enableLogging(configs.enableLogging);\n  firebase._ = (0, _merge2.default)({\n    watchers: {},\n    listeners: {},\n    callbacks: {},\n    queries: {},\n    config: configs,\n    authUid: null\n  }, firebase._);\n\n  var withMeta = function (method, path, value, onComplete) {\n    if ((0, _isObject2.default)(value)) {\n      var prefix = \"update\" === method ? \"updated\" : \"created\",\n          dataWithMeta = _objectSpread({}, value, _defineProperty({}, \"\".concat(prefix, \"At\"), firebase.database.ServerValue.TIMESTAMP));\n\n      return firebase.auth().currentUser && (dataWithMeta[\"\".concat(prefix, \"By\")] = firebase.auth().currentUser.uid), firebase.database().ref(path)[method](dataWithMeta, onComplete);\n    }\n\n    return firebase.database().ref(path)[method](value, onComplete);\n  },\n      actionCreators = (0, _actions.mapWithFirebaseAndDispatch)(firebase, dispatch, {\n    signInWithPhoneNumber: authActions.signInWithPhoneNumber\n  }, {\n    initializeAuth: authActions.init\n  });\n\n  return firebaseInstance = Object.assign(firebase, _objectSpread({\n    _reactReduxFirebaseExtended: !0,\n    ref: function ref(path) {\n      return firebase.database().ref(path);\n    },\n    set: function set(path, value, onComplete) {\n      return firebase.database().ref(path).set(value, onComplete);\n    },\n    setWithMeta: function setWithMeta(path, value, onComplete) {\n      return withMeta(\"set\", path, value, onComplete);\n    },\n    uniqueSet: function uniqueSet(path, value, onComplete) {\n      return firebase.database().ref(path).transaction(function (d) {\n        return null === d ? value : void 0;\n      }).then(function (_ref) {\n        var committed = _ref.committed,\n            snapshot = _ref.snapshot;\n\n        if (!committed) {\n          var newError = new Error(\"Path already exists.\");\n          return onComplete && onComplete(newError), Promise.reject(newError);\n        }\n\n        return onComplete && onComplete(snapshot), snapshot;\n      });\n    },\n    push: function push(path, value, onComplete) {\n      return firebase.database().ref(path).push(value, onComplete);\n    },\n    pushWithMeta: function pushWithMeta(path, value, onComplete) {\n      return withMeta(\"push\", path, value, onComplete);\n    },\n    remove: function remove(path, onComplete, options) {\n      return queryActions.remove(firebase, dispatch, path, options).then(function () {\n        return \"function\" == typeof onComplete && onComplete(), path;\n      });\n    },\n    update: function update(path, value, onComplete) {\n      return firebase.database().ref(path).update(value, onComplete);\n    },\n    updateWithMeta: function updateWithMeta(path, value, onComplete) {\n      return withMeta(\"update\", path, value, onComplete);\n    },\n    login: function login(credentials) {\n      return authActions.login(dispatch, firebase, credentials);\n    },\n    handleRedirectResult: function handleRedirectResult(authData) {\n      return authActions.handleRedirectResult(dispatch, firebase, authData);\n    },\n    logout: function logout() {\n      return authActions.logout(dispatch, firebase);\n    },\n    updateAuth: function updateAuth(authUpdate, updateInProfile) {\n      return authActions.updateAuth(dispatch, firebase, authUpdate, updateInProfile);\n    },\n    updateEmail: function updateEmail(newEmail, updateInProfile) {\n      return authActions.updateEmail(dispatch, firebase, newEmail, updateInProfile);\n    },\n    updateProfile: function updateProfile(profileUpdate, options) {\n      return authActions.updateProfile(dispatch, firebase, profileUpdate, options);\n    },\n    uploadFile: function uploadFile(path, file, dbPath, options) {\n      return storageActions.uploadFile(dispatch, firebase, {\n        path: path,\n        file: file,\n        dbPath: dbPath,\n        options: options\n      });\n    },\n    uploadFiles: function uploadFiles(path, files, dbPath, options) {\n      return storageActions.uploadFiles(dispatch, firebase, {\n        path: path,\n        files: files,\n        dbPath: dbPath,\n        options: options\n      });\n    },\n    deleteFile: function deleteFile(path, dbPath) {\n      return storageActions.deleteFile(dispatch, firebase, {\n        path: path,\n        dbPath: dbPath\n      });\n    },\n    createUser: function createUser(credentials, profile) {\n      return authActions.createUser(dispatch, firebase, credentials, profile);\n    },\n    resetPassword: function resetPassword(credentials) {\n      return authActions.resetPassword(dispatch, firebase, credentials);\n    },\n    confirmPasswordReset: function confirmPasswordReset(code, password) {\n      return authActions.confirmPasswordReset(dispatch, firebase, code, password);\n    },\n    verifyPasswordResetCode: function verifyPasswordResetCode(code) {\n      return authActions.verifyPasswordResetCode(dispatch, firebase, code);\n    },\n    watchEvent: function watchEvent(type, path, storeAs) {\n      var options = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n      return queryActions.watchEvent(firebase, dispatch, _objectSpread({\n        type: type,\n        path: path,\n        storeAs: storeAs\n      }, options));\n    },\n    unWatchEvent: function unWatchEvent(type, path, queryId) {\n      var options = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : {};\n      return queryActions.unWatchEvent(firebase, dispatch, _objectSpread({\n        type: type,\n        path: path,\n        queryId: queryId\n      }, options));\n    },\n    reloadAuth: function reloadAuth() {\n      return authActions.reloadAuth(dispatch, firebase);\n    },\n    linkWithCredential: function linkWithCredential(credential) {\n      return authActions.linkWithCredential(dispatch, firebase, credential);\n    },\n    promiseEvents: function promiseEvents(watchArray, options) {\n      var inputAsFunc = (0, _utils.createCallable)(watchArray),\n          prevData = inputAsFunc(options, firebase),\n          queryConfigs = (0, _utils.getEventsFromInput)(prevData);\n      return Promise.all(queryConfigs.map(function (queryConfig) {\n        return queryActions.watchEvent(firebase, dispatch, queryConfig);\n      }));\n    },\n    dispatch: dispatch\n  }, actionCreators)), firebaseInstance;\n}\n\nfunction getFirebase() {\n  if (!firebaseInstance) throw new Error(\"Firebase instance does not yet exist. Check your compose function.\");\n  return firebaseInstance;\n}","map":null,"metadata":{},"sourceType":"script"}